# Dynamin Programming

`동적 계획법(Dynamic Programming)` 의 패러다임은 다음과 같이 볼 수 있다.

1. 문제를 여러 개의 부분 문제로 나눈다.
2. 중복되는 부분 문제는 매번 새로 계산하지 않고, 계산 결과를 저장해놨다가 다시 사용한다.

## 동적 계획법을 적용할 수 있는 문제들

동적 계획법을 적용하여 풀이할 수 있는 문제들은 아래와 같다.

1. `최적 부분 구조(Optimal Substructure)` 를 가진 문제
2. `중복되는 부분 문제(overlapping subproblems)`를 가진 문제
3. `메모이제이션(memoization)`을 적용할 수 있는 문제

## 최적 부분 구조

- __최적 부분 구조(Optimal SubStructure)__: 문제를 해결하는 최적의 방법이 부분 문제를 해결하는 최적의 방법들로 구성되는 경우를 뜻한다.
- 예를 들어 a-b-c로 경로가 있을 때 최단 경로를 찾는다고 하자. a에서 b로 가는 경로와 b에서 c로 경로가 몇가지씩 있다고 하면 동적계획법을 적용했을 때 다음과 같이 구할 수 있따.

```
(1)을 해결하는 최적의 방법 = (2)를 해결하는 최적의 방법 + (3)을 해결하는 최적의 방법
(a-c의 최단 경로) = (a-b의 최단 경로) + (b-c의 최단경로)
```

## 중복되는 부분 문제

- __중복되는 부분 문제(overlapping subproblems)__: 하나의 문제를 여러 부분으로 나누었을 때, 두 번 이상 계산되는 부분 문제를 의미한다.

`예) 피보나치 수열`

```python
def F(n):
    if n == 0 or n == 1:
        return 1
    return F(n-1)+F(n-2)
```

`F(5)`를 계산하기 위해 `F(1)`과 `F(2),F(3)`이 여러 번 호출되는 것을 볼 수 있다.

```
F(5) = F(3)+F(4) = F(1)+F(2)+F(2)+F(3) = ...
```



## 메모이제이션과 참조적 투명성

- 메모이제이션 : 한번 계산한 값을 저장해두었다가 재활용하는 것이다.
- 참조적 투명성(referential transparency): 입력값이 같다면 함수가 언제나 같은 반환값을 내는 것을 의미하낟.
- 메모이제이션을 적용하기 위해서 함수는 참조적 투명성을 가져야 한다. 피보나치 수열을 계산할 때 F(2)를 저장해놓았다면 그 값이 언제나 같길 원할 것이다.



## 동적 계획법의 방법론

1. 상향식(Bottom-up)
2. 하향식(Top-Down)

### 상향식

- 더 작은 하위 문제부터 계산한 후, 이 문제드르이 계산결과를 이용하여 더 큰 문제를 계산한다.
  - `타뷸레이션(tabulation)`이라고도 한다.
  - 반복문을 사용한다.
  - 함수 호출로 인한 오버헤드가 없다. 시간과 메모리를 더 절약할 수 있다.

### 하향식

- 더 큰 문제를 호출한 후, 하위 문제가 계산되었는지 확인하며 문제를 계산한다.
- `메모이제이션(memoization)`이라고도 한다.
- 재귀를 사용한다.
- 가독성이 좋으며, 본래의 점화식의 형태를 따르므로 자연스럽다.

## 동적 계획법으로 알고리즘 설계하기

동적 계획법으로 문제를 푸려면 크게 세 단계를 거쳐야 한다.

1. 문제를 정의하고 더 작은 부분 문제로 나누기
2. 동적 계획법을 적용할 수 있는 문제인지 확인하기
3. 방법론 선택하고 구현하기



### 1. 문제를 정의하고 더 작은 부분 문제로 나누기

1. 문제 F(n) 정의하기 

> F(n) = 피보나치 수열에서 n번쨰에 있는 항

2. F(n) 을 더 작은 부분 문제로 나누기

> 피보나치 수열을 점화식으로 표현하면 아래와 같다.
>
> F(n) = 1 (n==0 or n == 1)
>
> ​	= f(n-1) + f(n-2) (n >= 2)



### 2. 동적 계획법을 적용할 수 있는 문제인지 확인하기

1. 최적부분구조를 가진다: f(n)`을 해결하는 방법은 `f(n-2)`와 f(n-1)`를 해결하는 방법으로 구성되어 있다.
2. 중복되는 부분 문제를 가진다: `f(n)`을 호출한다면 어떤 `k(k < n)`에 대하여 `f(k)`는 여러 번 호출된다.
3. 참조적 투명 함수이다. `f(n)`은 언제 어디서 호출하든 같은 값을 반환한다.



### 방법론 선택하고 구현하기

- 상향식(bottom-up)

```python
def f(n):
    dp[0] = 1
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

- 반복문을 사용하여 더 작은 문제부터 풀이한다 `i` 는 2~n까지 오름차순으로 올라가고 있다.



- 하향식(top-down)

```python
def f(n):
    if n <= 1:
        return 1
    if dp[n]:
        return dp[n]
    
    dp[n] = f(n - 1) + f(n - 2)
    return dp[n]
    
```

- 재귀를 사용하여 더 큰 문제부터 호출한다: `f(n)`을 호출한 후 `f(n-1)`와 `f(n-2)`을 호출한다. 중복되는 부분 문제라는 점을 이용하여 `dp[n]`이 저장되어 있다면 그 결과를 반환하고 있다.



### 동적 계획법으로 알고리즘 구현하기

1. 기저 사례
2. 메모이제이션
3. 로직
4. 초기화

```python
def f(n):
    # 기저
    if (...) return ...

	# 메모이제이션
    if dp[n]:
        return dp[n]
    
    # 값을 계산
    dp[n] = ...
    
    if __name__=='__main__':
        # 배열을 0으로 초기화
        dp = [0] * MAX_SIZE
```

1. 기저 사례

```python
if n == 0 or n == 1:
    return 1
```

- 기저 사례를 먼저 정의하여, 범위를 벗어나지 않도록 한다.

2. 메모이제이션

```python
if dp[n]:
    return dp[n]
```

- 이미 계산하여 저장한 값이 있다면, 그 값을 반환한다.

3. 로직

```python
dp[n] = f(n - 1) + f(n - 2)
```

- 값을 계산한다.

4. 초기화

```python
from collections import defaultdict

if __name__=='__main__':
    dp = defaultdict(int)
```

- 메모이제이션을 위해 결과를 저장할 딕셔너리를 초기화한다.



피보나치 수열의 하향식 전체 코드

```python
from collections import defaultdict

def f(n):
    # 기저
    if n <= 1:
        return n
    # 메모이제이션
    if dp[n]:
        return dp[n]
    # 구현
    dp[n] = f(n - 1) + f(n - 2)
    return dp[n]

if __name__='__main__':
    N = int(input())
    dp = defaultdict(int)
    print(f(N))
```



## 동적 계획법으로 풀 수 있는 문제들

- 배낭 문제

> 배낭에 최대 n kg만큼 넣을 수 있다. 각 물건마다 k 의 무게와 w 의 가치가 주어지며,물건은 쪼갤 수 없다.(가령 4kg의 벽돌은 1kg의 벽돌 4개로 쪼갤 수 없다)

```
0-1 배낭문제(0-1knapsack problem) 은 배낭 문제 중 짐을 쪼갤 수 없는 경우를 의미한다. 이 문제는 동적 계획법으로 풀 수 있다.
```

이와 달리 짐을 쪼갤 수 있다면 __분할 가능 배낭 문제__ 라고 한다. 이 문제는 그리디 알고리즘으로 풀 수 있다.



- 동전 문제

> 동전이 n 종류 주어진다 k 원을 만들기 위해 필요한 최소한의 동전 개수는 몇 개인가?

0 - 1 배낭 문제에서처럼 모든 동전을 넣어보며 최선의 결과를 도출한다.

